#   架构层面
* 新增模块若需要提供接口供客户端调用,需要注册相应的协议ID,编写相应的request和response,并在message.xml配置文件配置request相关类名.
* 新增模块需要在全局的springContext中注册getService()方法,供其他模块调用.
* 根据业务逻辑是否需要编写缓存接口与加载机制.
* 玩家登陆会根据玩家信息和账号线程池内数目(hash?取余)决定处理线程.
* service都是单例模式.

#   线程池
* AccountExecutor线程池 (运行时CPU数量决定)
* 持久化线程池(5,10,,15,20,25,30s) (逻辑决定)
* 日志记录线程池 (异步记录,大小为1)
* 客户端请求经过拼拆包最终会交由AccountExecutor线程池submit
* 场景线程池中玩家数据需要做同步,目前是玩家线程池推送同步,后续可能需要做双向同步

#   模块内部
目录结构:
* --constant : 常量,枚举等定义
* --entity   : DB对应类(缓存机制,序列化机制...)
* --event    : 事件定义
* --facade   : 请求处理,事件处理等逻辑
* --model    : 逻辑中的对象定义
* --packet   : 底层netty数据包request和response定义
* --resource : 静态资源文件
* --service  : 具体逻辑接口,由数据包和框架决定request的调用逻辑

* 在模块facade目录中提供调用方法,事件处理等方法(所需request,常量,对象定义需要遵循编码规范).
* entity实体类编写(如果数据需要持久化),根据业务需求,实现数据持久化时的序列化功能.
* 异常的分类处理,request异常和其他异常应当根据业务需求采用不同的处理机制.
* 根据业务需求是否需要注册事件机制,并编写响应的处理逻辑.
* 通过spring上下文调用其他模块接口.

#   静态资源加载
@Resource 根据相同类名加载同名资源文件(支持@Id 主键等注解)
@Static<T> T类型文件要求使用Resource注解,对应静态资源文件名和字段. eg: @Static修饰StorageLong<T> 
@Static(value = "id" initializeMethodName = "methodName") 根据id加载内容,methodName实现预处理加载逻辑.例如ConfigValue<T>.
csv: type对应(normal,json,array) clz对应代码的(string,integer,double...,map,list等)
@Id 标志id位不重复.
@Index(name = "indexName",unique=?) 索引支持,是否唯一.(底层unique=false时,StorageData对应的是一个List<V>,否则对应的是V,都采用HashMap存储)
对应可能发生的拆箱装箱现象,底层采用NonBlockingHashMapLong做存储(目前仅限LongKey对应).

#   代码规范
* 需要复用的工具类应当抽取到utils包下.
* 以valueOf(params...)形式加载对象.
* 提示信息关联I18n.
* 接口中的不变的数据以常量定义,并添加注释.
* 接口中方法添加注释.
* 代码加强可读性,需要适当注释.
* 枚举提供get()方法.
* Class等代码文件需要添加开发人信息,并且包含继承,实现等行为时需要添加简短的注释说明.

#   业务逻辑
* 涉及到玩家逻辑,应该判断player是否已经解锁该功能接口.
* 修改需要持久化的数据首先修改缓存,再推送DB的修改事件.
* 向客户端回写消息通过channel回写byteBuf即可,业务逻辑失败也可以不回写消息(根据具体业务决定).
* logger使用根据情况选择不同级别,使用{}占位符打印参数.
* 数据流向可以使用GM接口测试.
* 若接口内容器有线程安全问题,考虑使用线程安全的容器,或者提供线程安全的API.

#   开发流程
* 开发文档有详细的分工,开发内容,进度需要对接三方(策划-客户端-服务端),并交流具体内容,进度等...
* 开发多个任务,应该按照优先级安排进度.
* 若申请数据包协议号,需要与开发人员交流,避免冲突.
* 提交代码需要规范提交信息.

#   战斗流程
野外刷怪:客户端刷出一波怪(满血,全新的) 后端计算这波怪杀完要多久,前端播放技能特效.
pvp: 服务器模拟双方打架过程(玩家移动,buff,技能等) 生成日志纪录发送给客户端,客户端拿日志自己还原战斗动画.
打boss:服务器定时(1s)模拟玩家操作,生成日志记录,客户端模拟场景内动画.

#   人物技能,属性
* 血脉天赋学习:
  * 检查用户session,并且判断传入的用户id是否和session中的吻合.
  * 调用升级天赋接口
    * 玩家是否解锁该功能
    * 验证天赋
      * 获取玩家的血脉天赋信息
      * 根据天赋id,获取天赋配置
      * 玩家天赋和天赋配置type不同,参数有误
      * 检查该项天赋是否有升级条件,有则检查是否满足
      * 判断该天赋是否等级到达max
      * 根据天赋的技能id和技能等级 查出下一层天赋信息 称之为新天赋
      * 判断玩家职业是否可以学习该新天赋
      * 玩家剩余天赋点数是否满足学习新天赋所需点数
      * 判断玩家其他系技能是否满足新天赋的要求 (某些天赋需要其他系天赋学习到一定地步,目前仅根据各系消耗的天赋点判断)
      * 获取玩家学习天赋至今所消耗的点数,判断是否满足新天赋的前置要求
      * 用技能id查询该天赋该技能所有等级的天赋信息,判断新天赋是否已经学习过
      * 检查前置技能是否满足
      * 道具检测,消耗是否通过,并且消耗道具
      * 计算扣除之后剩余的天赋点
    * 根据技能id,技能新等级获取下一层天赋信息 
    * 替换旧天赋
      * 天赋技能表加入技能id,
      * 更新[天赋技能组-最大技能等级id]的Map 
      * 更新[类型-消耗天赋点]的Map
      * 替换旧天赋
    * 是否需要触发新天赋学习后的战场外效果
    * 玩家技能表修改入库
    * 修改玩家属性模块
      * 计算新属性以及不包含buff的属性
      * 不是加载原因,触发属性改变事件,是否需要做同步
        * 找到本次变化的属性,发送给客户端
        * 没找到则发送所有属性给客户端
        * 根据需求是否需要同步计算后的战斗力到fighter上
    * 同步新天赋到fighter
    * 更新天赋技能升级response到客户端
    * 刷新玩家的血脉天赋模块属性 
    * 玩家血脉天赋表修改入库
    * 推送血脉天赋升级事件  (暂时无消费者)
      
          

#   竞技场
* 匹配对手,并且对战:
  * 检查该玩家是否组队? : 是-不能进入地图
  * 刷新匹配对手CD (该功能暂时被注释)
  * 是否满足双倍挑战的条件 
  * 匹配对手成功? : 否-匹配失败,报错返回
    * 第一次匹配? : 是-则返回特殊机器人ID
    * 加载对应段位的pvp玩家,赛季信息,机器人信息,玩家自己段位
    * 玩家段位>2? : 否-则不能够匹配玩家
    * 50%向上匹配几率,grade到达gradeMax,向下匹配
    * 随机匹配
  * 处理战斗 : 查询匹配对手战斗信息,封装任务到pvp线程池,根据返回值判断是否成功执行 (该逻辑开始到结束会使用写锁)

#   装备强化
* 锻造强化 (部分检查功能强化与附魔共享)
    * 检查用户session及请求中的用户id是否吻合
    * 检查装备是否可以强化
        * 用户有效检查 装备有效检查(是有时间限制的装备不能被强化)
    * 根据装备Id获取当前装备上展示的属性(SlotAttribute.class)
    * 获取装备在装备栏的位置index
    * 获取该装备的的动态信息[装备部位,玩家职业,强化等级...EnhancePiece]
    * 获取该装备强化配置的静态资源文件     
        * 获取装备当前等级 判断是否已经强化到max,是否达到强化上限
        * 获取Consume接口 检查是否可以正常消耗强化所需的材料
    * 获取装备下一等级的配置静态资源文件
    * 检查是否需要突破,突破需要检查突破条件[x个角色达到y件装备分别强化到等级z]
    * 消耗材料
        * 检查玩家物品库存,消耗参数,
        * 刷新物品状态(是否过期-(方法废除))
        * 材料消耗顺序 即将过期-绑定的-剩余的
    * 保存消耗之后的背包状态入库
    * 回写消息

#   条件检查配置 Condition (Great-->大于 Less-->小于)
* ICondition接口 [抛出异常的检查,返回bool的检查方法]
    * AbstractCondition 上接口的抽象实现类 [初始化参数,检查逻辑等方法] 实现的方法调用该类自己的检查逻辑方法完成
        * 具体Condition类[继承上抽象类] 其class作ConditionType [Enum]的枚举参数
        * AndCondition,OrCondition 同上. 内部有一个CollectModel<AbstractCondition ? T> 的集合,其内部是一个对象或者是一个List
* ConditionDef [游戏中业务的条件配置数据!!!只是数据配置,需要转化为接口才能做业务,在init方法里做转化逻辑]
    * ConditionType 枚举参数
    * value 业务数据
    * 通过静态资源文件加载
    * 模块自行转化数据为枚举接口
* 例如练功(大)突破时,检查是否满足突破条件,调用这一层内功的静态资源文件调用其初始化后的ICondition进行检查   

#   消耗检查配置
* IConsume [四种检查方法(消耗倍数倍数,返回bool或者抛出异常),两种消耗方法(消耗倍率)]
    * AbstractConsume 上接口的抽象实现类 [初始化参数,逻辑检查,消耗,合并消耗等抽象方法]
        * 具体Consume类[继承上抽象类] 其class作ConsumeType的枚举参数

#   奖励配置 IReward (暂时接口无定义)
* IReward 暂时无定义
    * AbstractReward 上接口的抽象实现类 [初始化参数,合并奖励,检查数据合理性(默认不检查,需要自行实现)等方法]

#  属性
*    属性容器  [抽象类] AttributeContainer<T> [业务中属性容器的顶级抽象类]
    *   finalAttributes :   [攻击力,护甲,3s回血等属性]
    *   modelAttributeSet:  [元素,宝石,基础等模块] 每个模块提供上述属性
    
*    属性类型  [枚举]   AttributeType [字段:属性id,描述,是否与其他属性相关,属性计算器]
    * getEffectAttributes() 返回影响的属性数组
    * getCalculateAttributes() 返回需要同时[累加]计算的属性 [物理攻击下限受:攻击力,攻击力下限,物理攻击力,物理攻击力下限影响]
    * getCalculateRateAttributes() 返回对此属性具有百分比加成的其他属性

*    属性计算  [接口]   IAttributeComputer [方法:获取属性类型,计算基本属性...]
*    属性模块  [普通类] Attribute 字段:[属性类型-AttributeType,属性值] 
    
#   玩家相关加载 [通过事件机制]
*   消费者:[神器重铸,血脉天赋,角色Buff,外观,装备栏,大师装备,装备星级加成数据,经验精灵数据,天赋技能,内功,
             宝石数据,传世装备,传世套装,法阵数据,法宝栏数据,器魂数据,灵丹数据,转生数据,神盾数据,技能信息(skill),
             魂尘数据,灵器数据,灵器套装数据,雷霆套装数据,神翼数据,小助手数据,元素背包数据,头衔荣誉数据,
             图鉴数据,回收炉数据,神兵数据,称号数据,vip会员数据]
             
*   服务器启动调用FighterService加载逻辑将活跃玩家下的所有角色加载,同时同步地去加载玩家数据[技能,模块属性,天赋,背包数据...]
    * 玩家技能加载 SkillService doAfterPlayerLoad()
        *   拿到玩家技能集合,迭代[获取当前等级的技能资源文件, 获取对技能有分数加成的天赋id, 获取已经学习到顶级的技能id, 计算分数并赋值给玩家技能]
        *   刷新技能槽组
        *   设置默认技能
        *   设置技能树 
        
*   上述消费者内容全部加载完成后,会重新总结计算[通过属性计算器完成]玩家的总属性 [各个模块提供的攻击力,护甲,生命值...]总结到玩家基本属性中
      
#   玩家背包
*   GameObject 包含uniqueId
*   AbstractItem [物品的抽象类 继承了GameObject],[字段:id,数量,状态,过期时间]
*   ItemStorage  [物品储存库 抽象类],[字段:size,AbstractItem[]]
 
