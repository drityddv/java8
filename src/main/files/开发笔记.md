###架构层面
* 新增模块若需要提供接口供客户端调用,需要注册相应的协议ID,编写相应的request和response,并在message.xml配置文件配置request相关类名.
* 新增模块需要在全局的springContext中注册getService()方法,供其他模块调用.
* 根据业务逻辑是否需要编写缓存接口与加载机制.
* 玩家登陆会根据玩家信息和账号线程池内数目(hash?取余)决定处理线程.
* service都是单例模式.

#####线程池
* AccountExecutor线程池 (运行时CPU数量决定)
* 持久化线程池(5,10,,15,20,25,30s) (逻辑决定)
* 日志记录线程池 (异步记录,大小为1)
* 客户端请求经过拼拆包最终会交由AccountExecutor线程池submit
* 场景线程池中玩家数据需要做同步,目前是玩家线程池推送同步,后续可能需要做双向同步

###模块内部
目录结构:
* --constant : 常量,枚举等定义
* --entity   : DB对应类(缓存机制,序列化机制...)
* --event    : 事件定义
* --facade   : 请求处理,事件处理等逻辑
* --model    : 逻辑中的对象定义
* --packet   : 底层netty数据包request和response定义
* --resource : 静态资源文件对象定义
* --service  : 具体逻辑接口,由数据包和框架决定request的调用逻辑

* 在模块facade目录中提供调用方法,事件处理等方法(所需request,常量,对象定义需要遵循编码规范).
* entity实体类编写(如果数据需要持久化),根据业务需求,实现数据持久化时的序列化功能.
* 异常的分类处理,request异常和其他异常应当根据业务需求采用不同的处理机制.
* 根据业务需求是否需要注册事件机制,并编写响应的处理逻辑.
* 通过spring上下文调用其他模块接口.

###静态资源加载
@Resource 根据相同类名加载同名资源文件(支持@Id 主键等注解)
@Static<T> T类型文件要求使用Resource注解,对应静态资源文件名和字段. eg: @Static修饰StorageLong<T> 
@Static(value = "id" initializeMethodName = "methodName") 根据id加载内容,methodName实现预处理加载逻辑.例如ConfigValue<T>.
csv: type对应(normal,json,array) clz对应代码的(string,integer,double...,map,list等)
@Id 标志id位不重复.
@Index(name = "indexName",unique=?) 索引支持,是否唯一.(底层unique=false时,StorageData对应的是一个List<V>,否则对应的是V,都采用HashMap存储)
对应可能发生的拆箱装箱现象,底层采用NonBlockingHashMapLong做存储(目前仅限LongKey对应).

###代码规范
* 需要复用的工具类应当抽取到utils包下.
* 以valueOf(params...)形式加载对象.
* 提示信息关联I18n.
* 接口中的不变的数据以常量定义,并添加注释.
* 接口中方法添加注释.
* 代码加强可读性,需要适当注释.
* 枚举提供get()方法.
* Class等代码文件需要添加开发人信息,并且包含继承,实现等行为时需要添加简短的注释说明.

###业务逻辑
* 涉及到玩家逻辑,应该判断player是否已经解锁该功能接口.
* 修改需要持久化的数据首先修改缓存,再推送DB的修改事件.
* 向客户端回写消息通过channel回写byteBuf即可,业务逻辑失败也可以不回写消息(根据具体业务决定).
* logger使用根据情况选择不同级别,使用{}占位符打印参数.
* 数据流向可以使用GM接口测试.
* 若接口内容器有线程安全问题,考虑使用线程安全的容器,或者提供线程安全的API.

###开发流程
* 开发文档有详细的分工,开发内容,进度需要对接三方(策划-客户端-服务端),并交流具体内容,进度等...
* 开发多个任务,应该按照优先级安排进度.
* 若申请数据包协议号,需要与开发人员交流,避免冲突.
* 提交代码需要规范提交信息.

###战斗流程
野外刷怪:客户端刷出一波怪(满血,全新的) 后端计算这波怪杀完要多久,前端作假播放技能特效.
pvp: 服务器模拟双方打架过程(玩家移动,buff,技能等) 生成日志纪录发送给客户端,客户端拿日志自己还原战斗动画.
打boss:服务器定时(1s)模拟玩家操作,生成日志记录,客户端模拟场景内动画.

###人物技能,属性
* 血脉天赋学习:
  * 检查用户session,并且判断传入的用户id是否和session中的吻合.
  * 调用升级天赋接口
    * 玩家是否解锁该功能
    * 验证天赋
      * 获取玩家的血脉天赋信息
      * 根据天赋id,获取天赋配置
      * 玩家天赋和天赋配置type不同,参数有误
      * 检查该项天赋是否有升级条件,有则检查是否满足
      * 判断该天赋是否等级到达max
      * 查询该天赋下一层的数据,称之为新天赋
      * 判断玩家职业是否可以学习该新天赋
      * 玩家剩余天赋点数是否满足学习新天赋所需点数
      * 判断玩家其他系技能是否满足新天赋的要求 (某些天赋需要其他系天赋学习到一定地步)
      * 获取玩家学习天赋至今所消耗的点数,判断是否满足学习新天赋所需要的总点数
      * 用天赋id查询该天赋所有等级的天赋信息,判断新天赋是否已经学习过
      * 检查前置技能是否满足
      * 道具检测,消耗是否通过,并且消耗道具
      * 计算扣除之后剩余的天赋点
    * BloodGeniusService 214
    * 根据技能id,技能级别获取下一层技能信息  
      

###竞技场
* 匹配对手,并且对战:
  * 检查该玩家是否组队? : 是-不能进入地图
  * 刷新匹配对手CD (该功能暂时被注释)
  * 是否满足双倍挑战的条件 
  * 匹配对手成功? : 否-匹配失败,报错返回
    * 第一次匹配? : 是-则返回特殊机器人ID
    * 加载对应段位的pvp玩家,赛季信息,机器人信息,玩家自己段位
    * 玩家段位>2? : 否-则不能够匹配玩家
    * 50%向上匹配几率,grade到达gradeMax,向下匹配
    * 随机匹配
  * 处理战斗 : 查询匹配对手战斗信息,封装任务到pvp线程池,根据返回值判断是否成功执行 (该逻辑开始到结束会使用写锁)
  
#### 游戏代码逻辑 (已经了解)
* 注册
* 登陆
* 练功
* 联盟信息修改
* 竞技场决斗,匹配机制

