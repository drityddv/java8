#   架构层面
* 新增模块若需要提供接口供客户端调用,需要注册相应的协议ID,编写相应的request和response,并在message.xml配置文件配置request相关类名.
* 新增模块需要在全局的springContext中注册getService()方法,供其他模块调用.
* 根据业务逻辑是否需要编写缓存接口与加载机制.
* 玩家登陆会根据玩家信息和账号线程池内数目(hash?取余)决定处理线程.
* service都是单例模式.
* db缓存维护的是一个不过期的唯一对象,做修改操作可以直接用这个对象做.


#   线程池
* AccountExecutor线程池 (运行时CPU数量决定)
* 持久化线程池(5,10,,15,20,25,30s) (逻辑决定)
* 日志记录线程池 (异步记录,大小为1)
* 客户端请求经过拼拆包最终会交由AccountExecutor线程池submit
* 场景线程池中玩家数据需要做同步,目前是玩家线程池推送同步,后续可能需要做双向同步


#   模块内部
目录结构:
* --constant : 常量,枚举等定义
* --entity   : DB对应类(缓存机制,序列化机制...)
* --event    : 事件定义
* --facade   : 请求处理,事件处理等逻辑
* --gm       : gm后台命令支持
* --log      : 文件形式的日志操作
* --model    : 逻辑中的对象定义
* --packet   : 底层netty数据包request和response定义
* --resource : 静态资源文件
* --service  : 具体逻辑接口,由数据包和框架决定request的调用逻辑

* 在模块facade目录中提供调用方法,事件处理等方法(所需request,常量,对象定义需要遵循编码规范).
* entity实体类编写(如果数据需要持久化),根据业务需求,实现数据持久化时的序列化功能.
* 异常的分类处理,request异常和其他异常应当根据业务需求采用不同的处理机制.
* 根据业务需求是否需要注册事件机制,并编写响应的处理逻辑.
* 通过spring上下文调用其他模块接口.

#   静态资源加载
* @Resource 根据相同类名加载同名资源文件(支持@Id 主键等注解)
* @Static<T> T类型文件要求使用Resource注解,对应静态资源文件名和字段. eg: @Static修饰StorageLong<T> 
* @Static(value = "id" initializeMethodName = "methodName") 根据id加载内容,methodName实现预处理加载逻辑.例如ConfigValue<T>.
* csv: type对应(normal,json,array) clz对应代码的(string,integer,double...,map,list等)
* @Id 标志id位不重复.
* @Index(name = "indexName",unique=?) 索引支持,是否唯一.(底层unique=false时,StorageData对应的是一个List<V>,否则对应的是V,都采用HashMap存储)
* 对应可能发生的拆箱装箱现象,底层采用NonBlockingHashMapLong做存储(目前仅限LongKey对应).
* 不希望被违规修改的属性资源内容可以用ImmutableAttribute代替 [继承于Attribute,内部set操作都会抛出异常].


#   代码规范
* 需要复用的工具类应当抽取到utils包下.
* 以valueOf(params...)形式加载对象.
* 提示信息关联I18n.
* 接口中的不变的数据以常量定义,并添加注释.
* 接口中方法添加注释.
* 代码加强可读性,需要适当注释.
* 枚举提供get()方法.
* Class等代码文件需要添加开发人信息,并且包含继承,实现等行为时需要添加简短的注释说明.


#   业务逻辑
* 涉及到玩家逻辑,应该判断player是否已经解锁该功能接口.
* 修改需要持久化的数据首先修改缓存,再推送DB的修改事件.
* 向客户端回写消息通过channel回写byteBuf即可,业务逻辑失败也可以不回写消息(根据具体业务决定).
* logger使用根据情况选择不同级别,使用{}占位符打印参数.
* 数据流向可以使用GM接口测试.
* 若接口内容器有线程安全问题,考虑使用线程安全的容器,或者提供线程安全的API.
* session中的playerId是玩家账户中的第一个角色,前端做业务的传递的playerId需要做合法检查.
* 目前战斗只涉及属性,所以属性发生改变需要做此方面的同步.
* 战力发生改变,需要推送事件修改排行榜等处的战力信息.
* 部分后台关闭的特殊功能到达解锁等级并不会触发开放，只会保存在玩家开启的功能id表中，后台可以手动开启。
* 部分业务可以用整点事件来做。
* 发奖注意先扣掉发奖状态，以免发奖失败造成玩家刷奖的情况。


#   开发流程
* 开发文档有详细的分工,开发内容,进度需要对接三方(策划-客户端-服务端),并交流具体内容,进度等...
* 开发多个任务,应该按照优先级安排进度.
* 若申请数据包协议号,需要与开发人员交流,避免冲突.
* 提交代码需要规范提交信息.
* 协议号占坑注意合理安排区间。
* 三方提交后，上线重启主干，同时通知内网群。重启结束，也要通知。


#   人物技能,属性
* 血脉天赋学习:
  * 检查用户session,并且判断传入的用户id是否和session中的吻合.
  * 调用升级天赋接口
    * 玩家是否解锁该功能
    * 验证天赋
      * 获取玩家的血脉天赋信息
      * 根据天赋id,获取天赋配置
      * 玩家天赋和天赋配置type不同,参数有误
      * 检查该项天赋是否有升级条件,有则检查是否满足
      * 判断该天赋是否等级到达max
      * 根据天赋的技能id和技能等级 查出下一层天赋信息 称之为新天赋
      * 判断玩家职业是否可以学习该新天赋
      * 玩家剩余天赋点数是否满足学习新天赋所需点数
      * 判断玩家其他系技能是否满足新天赋的要求 (某些天赋需要其他系天赋学习到一定地步,目前仅根据各系消耗的天赋点判断)
      * 获取玩家学习天赋至今所消耗的点数,判断是否满足新天赋的前置要求
      * 用技能id查询该天赋该技能所有等级的天赋信息,判断新天赋是否已经学习过
      * 检查前置技能是否满足
      * 道具检测,消耗是否通过,并且消耗道具
      * 计算扣除之后剩余的天赋点
    * 根据技能id,技能新等级获取下一层天赋信息 
    * 替换旧天赋
      * 天赋技能表加入技能id,
      * 更新[天赋技能组-最大技能等级id]的Map 
      * 更新[类型-消耗天赋点]的Map
      * 替换旧天赋
    * 是否需要触发新天赋学习后的战场外效果
    * 玩家技能表修改入库
    * 修改玩家属性模块
      * 计算新属性以及不包含buff的属性
      * 不是加载原因,触发属性改变事件,是否需要做同步
        * 找到本次变化的属性,发送给客户端
        * 没找到则发送所有属性给客户端
        * 根据需求是否需要同步计算后的战斗力到fighter上
    * 同步新天赋到fighter
    * 更新天赋技能升级response到客户端
    * 刷新玩家的血脉天赋模块属性 
    * 玩家血脉天赋表修改入库
    * 推送血脉天赋升级事件  (暂时无消费者)


#   竞技场
* 匹配对手,并且对战:
  * 检查该玩家是否组队? : 是-不能进入地图
  * 刷新匹配对手CD (该功能暂时被注释)
  * 是否满足双倍挑战的条件 
  * 匹配对手成功? : 否-匹配失败,报错返回
    * 第一次匹配? : 是-则返回特殊机器人ID
    * 加载对应段位的pvp玩家,赛季信息,机器人信息,玩家自己段位
    * 玩家段位>2? : 否-则不能够匹配玩家
    * 50%向上匹配几率,grade到达gradeMax,向下匹配
    * 随机匹配
  * 处理战斗 : 查询匹配对手战斗信息,封装任务到pvp线程池,根据返回值判断是否成功执行 (该逻辑开始到结束会使用写锁)


#   装备强化
* 锻造强化 (部分检查功能强化与附魔共享)
  * 检查用户session及请求中的用户id是否吻合
  * 检查装备是否可以强化
    * 用户有效检查 装备有效检查(是有时间限制的装备不能被强化)
  * 根据装备Id获取当前装备上展示的属性(SlotAttribute.class)
  * 获取装备在装备栏的位置index
  * 获取该装备的的动态信息[装备部位,玩家职业,强化等级...EnhancePiece]
    * 获取该装备强化配置的静态资源文件     
      * 获取装备当前等级 判断是否已经强化到max,是否达到强化上限
      * 获取Consume接口 检查是否可以正常消耗强化所需的材料
  * 获取装备下一等级的配置静态资源文件
  * 检查是否需要突破,突破需要检查突破条件[x个角色达到y件装备分别强化到等级z]
  * 消耗材料
    * 检查玩家物品库存,消耗参数,
    * 刷新物品状态(是否过期-(方法废除))
    * 材料消耗顺序 即将过期-绑定的-剩余的
  * 保存消耗之后的背包状态入库
  * 回写消息


#   神翼强化
* 神翼提升
  * 检查玩家身份合法性,req请求参数合法性
  * 检查玩家是否开启该功能,神翼是否满级
  * 消耗道具或者元宝
  * 增加神翼经验,并且尝试升级
  * 升级之后推送相关事件
  * 如果升级了 [修改玩家该模块属性,重新计算战力,推送翅膀变更事件,修改入库]
  * 根据升级情况,向前端推送更新后的神翼数据


#   条件检查配置 Condition (Great-->大于 Less-->小于)
* ICondition接口 [抛出异常的检查,返回bool的检查方法]
  * AbstractCondition 上接口的抽象实现类 [初始化参数,检查逻辑等方法] 实现的方法调用该类自己的检查逻辑方法完成
    * 具体Condition类[继承上抽象类] 其class作ConditionType [Enum]的枚举参数
    * AndCondition,OrCondition 同上. 内部有一个CollectModel<AbstractCondition ? T> 的集合,其内部是一个对象或者是一个List
* ConditionDef [游戏中业务的条件配置数据!!!只是数据配置,需要转化为接口才能做业务,在init方法里做转化逻辑]
  * ConditionType 枚举参数
  * value 业务数据
  * 通过静态资源文件加载
  * 模块自行转化数据为枚举接口


#   消耗检查配置
* IConsume [四种检查方法(消耗倍数倍数,返回bool或者抛出异常),两种消耗方法(消耗倍率)]
  * AbstractConsume 上接口的抽象实现类 [初始化参数,逻辑检查,消耗,合并消耗等抽象方法]
    * 具体Consume类[继承上抽象类] 其class作ConsumeType的枚举参数

#  属性
* 属性容器  [抽象类] AttributeContainer<T> [业务中属性容器的顶级抽象类]
  * finalAttributes :   [攻击力,护甲,3s回血等属性]
  * modelAttributeSet:  [元素,宝石,基础等模块] 每个模块提供上述属性
    
* 属性类型  [枚举]   AttributeType [字段:属性id,描述,是否与其他属性相关,属性计算器
  * getEffectAttributes() 返回影响的属性数组
  * getCalculateAttributes() 返回需要同时[累加]计算的属性 [物理攻击下限受:攻击力,攻击力下限,物理攻击力,物理攻击力下限影响]
  * getCalculateRateAttributes() 返回对此属性具有百分比加成的其他属性

* 属性计算  [接口]   IAttributeComputer [方法:获取属性类型,计算基本属性...]
* 属性模块  [普通类] Attribute 字段:[属性类型-AttributeType,属性值] 


#   玩家相关加载 [通过事件机制]
* 消费者:[神器重铸,血脉天赋,角色Buff,外观,装备栏,大师装备,装备星级加成数据,经验精灵数据,天赋技能,内功,
             宝石数据,传世装备,传世套装,法阵数据,法宝栏数据,器魂数据,灵丹数据,转生数据,神盾数据,技能信息(skill),
             魂尘数据,灵器数据,灵器套装数据,雷霆套装数据,神翼数据,小助手数据,元素背包数据,头衔荣誉数据,
             图鉴数据,回收炉数据,神兵数据,称号数据,vip会员数据]

* 服务器启动调用FighterService加载逻辑将活跃玩家下的所有角色加载,同时同步地去加载玩家数据[技能,模块属性,天赋,背包数据...]
  * 玩家技能加载 SkillService doAfterPlayerLoad()
    *   拿到玩家技能集合,迭代[获取当前等级的技能资源文件, 获取对技能有分数加成的天赋id, 获取已经学习到顶级的技能id, 计算分数并赋值给玩家技能]
    *   刷新技能槽组
    *   设置默认技能
    *   设置技能树

* 上述消费者内容全部加载完成后,会重新总结计算[通过属性计算器完成]玩家的总属性 [各个模块提供的攻击力,护甲,生命值...]总结到玩家基本属性中


#   玩家背包
* GameObject 包含uniqueId
* AbstractItem [物品的抽象类 继承了GameObject],[字段:id,数量,状态,过期时间]
* ItemStorage  [物品储存库 抽象类],[字段:size,AbstractItem[]]


#   如何添加一个新属性模块
* 模块需要注册AttributeIdEnum枚举,作为修改玩家属性的Id
* 该模块监听用户加载,用户登录事件,然后加载玩家模块属性数据[从静态资源文件中读取]到玩家属性容器中,重新计算玩家基本属性
* 玩家模块数据持久化 [网站有查询需求,可以加部分信息字段]
* facade包内提供服务类和事件消费逻辑
* 日志记录道具消耗
* 模块属性发生变化需要修改账号线程和场景线程的模块数据,后者自行同步到场景线程. 同时调用PlayAttributeContainer重新计算战力,同步战力到场景线程


#   客户端debug
* 用google可以断点调试前端资源，拿序列号一层一层寻找，可以debug后端返回数据是否有误。


#	命令
*	主干重启 10.11.3.32
*	home/t5game/trunk 启动对应脚本 参数：[-u 更新svn文件；-c 编译代码；-g restart...]
*	tail -n num -f 对应的log
