###架构层面
* 新增模块若需要提供接口供客户端调用,需要注册相应的协议ID,编写相应的request和response,并在message.xml配置文件配置request相关类名.
* 新增模块需要在全局的springContext中注册getService()方法,供其他模块调用.
* 根据业务逻辑是否需要编写缓存接口与加载机制.
* 静态资源文件加载,需要确保Id号对应,部分加载逻辑需要手动实现.
* 玩家登陆会根据玩家信息和账号线程池内数目(hash?取余)决定处理线程.
* service都是单例模式.

#####线程池
* AccountExecutor线程池 (运行时CPU数量决定)
* 持久化线程池(5,10,,15,20,25,30s) (逻辑决定)
* 日志记录线程池 (异步记录,大小为1)
* 客户端请求经过拼拆包最终会交由AccountExecutor线程池submit
* 场景线程池中玩家数据需要做同步,目前是玩家线程池推送同步,后续可能需要做双向同步

###模块内部
目录结构:
* --constant : 常量,枚举等定义
* --entity   : DB对应类(缓存机制,序列化机制...)
* --event    : 事件定义
* --facade   : 请求处理,事件处理等逻辑
* --model    : 逻辑中的对象定义
* --packet   : 底层netty数据包request和response定义
* --resource : 静态资源文件对象定义
* --service  : 具体逻辑接口,由数据包和框架决定request的调用逻辑

* 在模块facade目录中提供调用方法,事件处理等方法(所需request,常量,对象定义需要遵循编码规范).
* entity实体类编写(如果数据需要持久化),根据业务需求,实现数据持久化时的序列化功能.
* 异常的分类处理,request异常和其他异常应当根据业务需求采用不同的处理机制.
* 根据业务需求是否需要注册事件机制,并编写响应的处理逻辑.
* 通过spring上下文调用其他模块接口.

###静态资源加载
@Static 无特殊情况的资源文件加载.特殊情况(例如ConfigValue文件使用下面那种方式加载)
@Static(value = "id" initializeMethodName = "methodName") 根据id加载内容,methodName实现预处理加载逻辑.
@Id 标志id位不重复.
@Index(name = "indexName",unique=?) 索引支持,是否唯一.(底层unique=false时,StorageData对应的是一个List<V>,否则对应的是V,都采用HashMap存储)
对应可能发生的拆箱装箱现象,底层采用NonBlockingHashMapLong做存储(目前仅限LongKey对应).

###代码规范
* 需要复用的工具类应当抽取到utils包下.
* 以valueOf(params...)形式加载对象.
* 提示信息关联I18n.
* 接口中的不变的数据以常量定义,并添加注释.
* 接口中方法添加注释.
* 代码加强可读性,需要适当注释.
* 枚举提供get()方法.
* Class等代码文件需要添加开发人信息,并且包含继承,实现等行为时需要添加简短的注释说明.

###业务逻辑
* 涉及到玩家逻辑,应该判断player是否已经解锁该功能接口.
* 修改需要持久化的数据首先修改缓存,再推送DB的修改事件.
* 向客户端回写消息通过channel回写byteBuf即可,业务逻辑失败也可以不回写消息(根据具体业务决定).
* logger使用根据情况选择不同级别,使用{}占位符打印参数.
* 数据流向可以使用GM接口测试.
* 若接口内容器有线程安全问题,考虑使用线程安全的容器,或者提供线程安全的API.

###开发流程
* 开发文档有详细的分工,开发内容,进度需要对接三方(策划-客户端-服务端),并交流具体内容,进度等...
* 开发多个任务,应该按照优先级安排进度.
* 若申请数据包协议号,需要与开发人员交流,避免冲突.
* 提交代码需要规范提交信息.
